#lang racket
(require "parser.rkt"
         (prefix-in stx: "syntax.rkt")
         (prefix-in sms: "semsyntax.rkt"))

(define ... '(a))
(struct decl    (name lev kind type) #:transparent)
(struct pointer (type)               #:transparent)
(struct array   (type size)          #:transparent)
(struct fun     (type params)        #:transparent)

(define (parse->sem parse lev)
  (define (star-type->type list)
    (if (null? (cdr list))
        (car list)
        (pointer (star-type->type (cdr list)))))
  (define (find-array-name array)
    (if (stx:array-exp? (stx:array-exp-name array))
        (find-array-name (stx:array-exp-name array))
        (car (stx:array-exp-name array))))
  (define (make-array-type arr)
    (if (stx:array-exp? (stx:array-exp-name arr))
        (array (make-array-type (stx:array-exp-name arr)) (stx:array-exp-size arr))
        (array (star-type->type (stx:array-exp-type arr)) (stx:array-exp-size arr))))
  (cond ((list? parse) (map (lambda (x) (parse->sem x 0)) parse))
        ((stx:declar? parse)
         (sms:declar
         (map
          (lambda (x)
            (if (stx:array-exp? x)
                (let (;(namepos (cdr (stx:array-exp-name x)))
                      (name (find-array-name x))
                      (size (stx:array-exp-size x))
                      (type (make-array-type x)))
                  (decl name lev 'var type))
                (let (;(namepos (cddr x))
                      ;(type-pos (stx:declar-pos parse))
                      (name (cadr x))
                      (type (star-type->type (car x))))
                  (decl name lev 'var type))))
          (stx:declar-declrs parse))))
        ((stx:fun-prot? parse)
         (let* ((name (stx:fun-prot-name parse))
               ;(namepos (cddr parse))
               (parms (map (lambda (x) (decl (cadr x) lev 'para (caar x))) (stx:fun-prot-parms parse)))
               (type (fun (star-type->type (stx:fun-prot-type parse))
                          (map (lambda (x) (star-type->type (caar x))) (stx:fun-prot-parms parse)))))
           (sms:fun-prot (stx:fun-prot-type parse)
                                   (decl name lev 'proto type)
                                   parms)))
        ((stx:fun-def? parse)
         (let* ((name (stx:fun-def-name parse))
               (parms (map (lambda (x) (decl (cadr x) (+ lev 1) 'para (caar x))) (stx:fun-def-parms parse)))
               (type (fun (star-type->type (stx:fun-def-type parse))
                          (map (lambda (x) (star-type->type (caar x))) (stx:fun-def-parms parse))))
               (body (parse->sem (stx:fun-def-body parse) (+ lev 1))))
         (sms:fun-def (star-type->type (stx:fun-def-type parse))
                                  (decl name lev 'fun type)
                                  parms
                                  body)))
        ((stx:if-stmt? parse) ...)
        ((stx:while-stmt? parse) ...)
        ((stx:return-stmt? parse) ...)
        ((stx:assign-exp? parse) ...)
        ((stx:log-exp? parse) ...)
        ((stx:rop-exp? parse) ...)
        ((stx:aop-exp? parse) ...)
        ((stx:deref-exp? parse) ...)
        ((stx:addr-exp? parse) ...)
        ((stx:array-exp? parse) `(array ,(parse->sem (stx:array-exp-type parse) lev) ,(parse->sem (stx:array-exp-size parse) lev)))
        ((stx:call-exp? parse) ...)
        ((stx:comma-exp? parse) ...)
        (else parse)))